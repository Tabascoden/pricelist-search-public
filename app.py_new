    @app.route("/search", methods=["GET"])
    def search():
        q = (request.args.get("q") or "").strip()
        supplier_id = (request.args.get("supplier_id") or "").strip()
        sort = (request.args.get("sort") or "rank").strip()
        limit = request.args.get("limit") or "60"
        category_ids_raw = request.args.get("category_ids") or request.args.get("category_id")

        try:
            limit_i = int(limit)
        except Exception:
            limit_i = 60
        limit_i = max(1, min(limit_i, 300))

        params: Dict[str, Any] = {"limit": limit_i}
        where = ["si.is_active IS TRUE"]

        if category_ids_raw:
            try:
                cids = [int(c) for c in str(category_ids_raw).split(",") if str(c).strip()]
            except Exception:
                cids = []
            if cids:
                params["category_ids"] = tuple(cids)
                where.append("si.category_id = ANY(%(category_ids)s)")

        if supplier_id:
            params["supplier_id"] = int(supplier_id)
            where.append("si.supplier_id = %(supplier_id)s")

        if q:
            # Разбиваем запрос на слова для гибкого поиска
            words = [w.strip() for w in q.split() if len(w.strip()) > 1]
            if not words:
                words = [q]
            
            # Формируем query для tsquery (слово1 & слово2 ...)
            # Но для гибкости используем вариативность
            ts_query = " & ".join([f"{w}:*" for w in words])
            params["ts_query"] = ts_query
            params["q_raw"] = q

            # SQL с использованием триграмм (similarity) и полнотекстового поиска
            if sort == "rank":
                order_by = "rank DESC, similarity DESC, si.price ASC NULLS LAST"
            elif sort == "price_asc":
                order_by = "si.price ASC NULLS LAST, rank DESC"
            elif sort == "price_desc":
                order_by = "si.price DESC NULLS LAST, rank DESC"
            elif sort == "ppu_asc":
                order_by = "si.price_per_unit ASC NULLS LAST, rank DESC"
            else:
                order_by = "rank DESC"

            sql = f"""
                SELECT
                  si.id,
                  si.supplier_id,
                  s.name AS supplier_name,
                  si.name_raw,
                  si.unit,
                  si.price,
                  si.base_unit,
                  si.base_qty,
                  si.price_per_unit,
                  si.category_id,
                  ts_rank_cd(to_tsvector('russian', si.name_raw), to_tsquery('russian', %(ts_query)s)) AS rank,
                  similarity(si.name_raw, %(q_raw)s) AS similarity
                FROM supplier_items si
                JOIN suppliers s ON s.id = si.supplier_id
                WHERE {" AND ".join(where)}
                  AND (
                    to_tsvector('russian', si.name_raw) @@ to_tsquery('russian', %(ts_query)s)
                    OR si.name_raw ILIKE '%%' || %(q_raw)s || '%%'
                    OR similarity(si.name_raw, %(q_raw)s) > 0.15
                  )
                ORDER BY {order_by}
                LIMIT %(limit)s;
            """
        else:
            # Если запроса нет, просто показываем последние/дешевые
            order_by = {
                "rank": "si.id DESC",
                "price_asc": "si.price ASC NULLS LAST",
                "price_desc": "si.price DESC NULLS LAST",
                "ppu_asc": "si.price_per_unit ASC NULLS LAST",
            }.get(sort, "si.id DESC")

            sql = f"""
                SELECT
                  si.id,
                  si.supplier_id,
                  s.name AS supplier_name,
                  si.name_raw,
                  si.unit,
                  si.price,
                  si.base_unit,
                  si.base_qty,
                  si.price_per_unit,
                  si.category_id,
                  0.0::float AS rank,
                  0.0::float AS similarity
                FROM supplier_items si
                JOIN suppliers s ON s.id = si.supplier_id
                WHERE {" AND ".join(where)}
                ORDER BY {order_by}
                LIMIT %(limit)s;
            """

        try:
            with db_connect() as conn:
                with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
                    # Устанавливаем порог для триграммного поиска
                    cur.execute("SET pg_trgm.similarity_threshold = 0.15;")
                    cur.execute(sql, params)
                    rows = cur.fetchall()
            items = [{k: _json_safe(v) for k, v in dict(r).items()} for r in rows]
            return jsonify({"q": q, "items": items})
        except Exception as e:
            app.logger.exception("Search error")
            return jsonify({"error": "internal error", "details": str(e)}), 500
